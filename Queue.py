#%%
from types import SimpleNamespace
import numpy as np
import matplotlib.pyplot as plt

class parameters:

    def __init__(self, X, Y=1.0, sim_sec=6000):
        self.sim_sec = sim_sec #simulated seconds
        self.inter_arrival_time = X #X = 1/lambda (mean inter arrival time)
        self.service_time = Y  #Y = 1/mu (mean service time)
        self.lambda_ = 1.0/self.inter_arrival_time # mean arrival rate
        self.mu = 1.0/self.service_time # mean service rate
        self.rho = self.lambda_/self.mu #traffic
        self.avg_jobs_sys= self.rho/(1-self.rho) # average num of jobs in system

    def distributions(self, rndseed): 
    #self.IAT: distribution of inter arrival times
    #self.ST: distribution of service times
    #self.AT: arrival time of each item
        self.rng = np.random.default_rng(rndseed)
        self.IAT = self.rng.exponential(scale=self.inter_arrival_time, size=self.sim_sec)
        self.AT = np.cumsum(self.IAT)
        self.ST = self.rng.exponential(scale=self.service_time, size=self.sim_sec)
        return SimpleNamespace(interarrival_time=self.IAT, arrive_time=self.AT, service_time=self.ST)


class service(parameters):

    def __init__(self,X,rndseed):
        super().__init__(X)
        self.d = self.distributions(rndseed)
        self.d.start_time = np.zeros(self.sim_sec)
        self.d.depart_time = np.zeros(self.sim_sec)
        self.num_items_in_qu = []

    def generate_Q_para(self):
        # this function calculates various time parameters for each packet/job
        #such as- start time, wait time, and depart time
        for idx in range(self.sim_sec):
            if idx==0:
                self.d.start_time[0] = self.d.arrive_time[0]
            else:
                self.d.start_time[idx] = max(self.d.arrive_time[idx], self.d.depart_time[idx-1])
            self.d.depart_time[idx] = self.d.start_time[idx] + self.d.service_time[idx]
        self.d.wait_time = self.d.start_time - self.d.arrive_time
        return self.d
    
    def count_Q(self):
        # this function generates a queue if a packet/job is in service
        #ultimately, it returns number of items in queue for each simulated second
        self.d = self.generate_Q_para()        
        self.curr_lst = []
        
        for idx in range(self.sim_sec):
            self.curr_lst.pop(0) if len(self.curr_lst)>0 else self.curr_lst
            
            self.wait_lst = [self.d.arrive_time[i+1] for i in range(idx,self.sim_sec-1) if self.d.arrive_time[i+1]<self.d.depart_time[idx]]
            self.curr_lst = list(dict.fromkeys(self.wait_lst+self.curr_lst))
            
            self.num_items_in_qu.append(len(self.curr_lst))
        return self.num_items_in_qu

    def fnDict(self):
        #returns a namespace of parameters generated by previous functions
        return SimpleNamespace(paraD=self.generate_Q_para(), qitem=self.count_Q())

def distributionPlots(df,X):
    # plots various box plots as subplots
    fig,(ax1,ax2,ax3) = plt.subplots(3,1,figsize=(8,8),constrained_layout=True)
    for idx in range(len(df)):
        ax1.boxplot(df[idx].paraD.interarrival_time,positions=[X[idx]])
        ax1.set_xlabel('inter arrival time(X)')
        ax1.set_ylabel('inter arrival time distribution')
        ax1.set_title('distribution of inter arrival time vs inter arrival time(X)')

        ax2.boxplot(df[idx].paraD.wait_time,positions=[X[idx]])
        ax2.set_xlabel('inter arrival time(X)')
        ax2.set_ylabel('wait time distribution')
        ax2.set_title('distribution of wait time vs inter arrival time(X)')

        ax3.boxplot(df[idx].paraD.service_time,positions=[X[idx]])
        ax3.set_xlabel('inter arrival time(X)')
        ax3.set_ylabel('service time distribution')
        ax3.set_title('distribution of service time vs inter arrival time(X)')

    plt.show()
    return

def timelinePlot(df):
    #plots the line plot in a graph
    plt.plot(df[0].qitem[:60], label='X=1.1')
    plt.plot(df[1].qitem[:60], label='X=1.5')
    plt.plot(df[2].qitem[:60], label='X=2')
    plt.legend()
    plt.xlabel('simulated sec (sec)')
    plt.ylabel('number of items in the queue')
    plt.title('timeline plot')

    plt.show()
    return


X = [1.1,1.5,2]
rndseed = [24,30,48]

obj = service
df = {idx: obj(val[0],val[1]).fnDict() for idx,val in enumerate(zip(X,rndseed))}
distributionPlots(df,X)
timelinePlot(df)



# %%
